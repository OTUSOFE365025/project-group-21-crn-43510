ADD — Iteration 1 (AIDAP)

This Architectural Design Document (ADD) contains all artifacts for Iteration 1 of AIDAP (AI‑Powered Digital Assistant Platform): logical & deployment architecture, sequence diagrams and methods, quality attributes, design decisions, analysis and progress

--------------------------------------------------------------------------------
Table of contents
- Logical Architecture
  - Architecture diagram (mermaid)
  - Component table
  - Rationale & acceptance
- Sequence Diagrams & Methods
  - Use Cases
  - Sequence 1: Student fetches deadlines
  - Sequence 2: Faculty posts announcement
  - Sequence 3: Admin requests analytics
  - Methods tables
- Deployment Architecture
  - Deployment diagram
  - Deployment table
  - Minimal deployment checklist
- Quality Attributes
  - Selected attributes, implementation, and tests
- Design Decisions
  - Decision table with alternatives and justification
- Analysis & Progress
  - Summary and progress table
  - Recommended next concrete tasks
- Example API Skeleton (for iteration demo)
- Scoring guidance / rubric mapping
- Tips to ensure full marks

--------------------------------------------------------------------------------
Logical Architecture

Architecture diagram (mermaid)
MERMAID DIAGRAM START
graph TD
  User[User (Student / Faculty / Admin)]
  WebUI[Web UI / Chat UI]
  API[API Gateway / REST API]
  Auth[Auth Service (OIDC / SSO)]
  Core[Core Assistant Service]
  AI[AI Engine (LLM + Retrieval)]
  VectorDB[Vector DB (embeddings)]
  DB[Primary DB (Postgres)]
  LMS[LMS Adapter (LTI/API)]
  Calendar[Calendar Adapter (Google/CalDAV)]
  Mail[Mail Adapter (SMTP/SendGrid)]
  Cache[Cache (Redis)]
  Analytics[Analytics Service]

  User --> WebUI
  WebUI --> API
  API --> Auth
  API --> Core
  Core --> AI
  Core --> DB
  Core --> Cache
  Core --> LMS
  Core --> Calendar
  Core --> Mail
  Core --> Analytics
  AI --> VectorDB
MERMAID DIAGRAM END

Component table (domain-specific)
- API Gateway / REST API
  - Description: Single entry point for UI and external clients; routes to services, rate-limits.
  - Responsibilities: Authentication, request validation, routing, metrics.
  - Example artifact: POST /api/v1/converse

- Auth Service (OIDC / SSO)
  - Description: Integrates institution SSO (SAML or OIDC) and issues short-lived tokens.
  - Responsibilities: Login redirect, token introspection, role claims (student/faculty/admin).
  - Example: /auth/callback

- Core Assistant Service
  - Description: Orchestrates conversation flows, session management, context windows, policy for external integrations.
  - Responsibilities: Maintains conversation state, calls AI Engine, calls adapters.
  - Public methods: startSession(), handleMessage()

- AI Engine (LLM + Retrieval)
  - Description: Uses LLM for answer generation plus vector retrieval for contextual data.
  - Responsibilities: Generate responses, fetch embedding matches.
  - Implementation example: OpenAI + embeddings stored in VectorDB

- Vector DB
  - Description: Stores embeddings for course materials, announcements, FAQs for retrieval.
  - Example: Pinecone / Milvus

- Primary DB (Postgres)
  - Description: Persistent store for users, sessions, course links, permission mapping.
  - Responsibilities: Data consistency, ACID storage of critical data.

- LMS Adapter
  - Description: Integrates with LMS (Canvas / Blackboard) to fetch course deadlines and announcements via API/LTI.
  - Responsibilities: Periodic sync + on-demand fetch.

- Calendar Adapter
  - Description: Sync with Calendar provider (Google Calendar / Office 365) for personal schedules.

- Mail Adapter
  - Description: Send notifications / announcements, uses transactional email provider.

- Cache (Redis)
  - Description: Session cache, rate-limiting counters, short-lived context storage.

- Analytics Service
  - Description: Aggregates usage metrics, response times, query patterns for admin dashboards.

Rationale (domain-specific):
- Orchestration in Core Service to apply role-based responses and privacy filters.
- LLM + retrieval to give contextual answers from institutional data (deadlines, announcements).
- Adapters for each external system to keep integration logic isolated.

Acceptance for "Exceeds":
- Diagram contains domain-specific elements above.
- Table lists each element with clear descriptions and responsibilities.

--------------------------------------------------------------------------------
Sequence Diagrams & Methods

Use Cases for Iteration 1 (chosen)
1. Student asks: "What are my deadlines for CS101 this week?"
2. Faculty posts announcement via UI -> Sync to LMS and notify students.
3. Admin requests: "Show course enrollment analytics for last week."

Sequence 1: Student fetches deadlines (mermaid)
MERMAID DIAGRAM START
sequenceDiagram
  participant U as User (Student)
  participant UI as Web UI
  participant API as API Gateway
  participant Auth as Auth Service
  participant Core as Core Assistant
  participant LMS as LMS Adapter
  participant DB as Postgres
  participant AI as AI Engine
  participant VDB as VectorDB

  U->>UI: sends "deadlines for CS101 this week"
  UI->>API: POST /api/v1/converse {msg, session}
  API->>Auth: validate token
  API->>Core: handleMessage(session,msg)
  Core->>DB: fetch user roles, enrollments
  Core->>LMS: fetch course deadlines (if not cached)
  Core->>VDB: retrieve relevant content embeddings
  Core->>AI: ask LLM to synthesize answer (context + deadlines)
  AI->>Core: generated response
  Core->>API: return response
  API->>UI: render response
MERMAID DIAGRAM END

Methods table (map diagram lifelines to names and methods)
- API Gateway
  - POST /api/v1/converse
  - POST /api/v1/session
- Core Assistant
  - startSession(userId) -> sessionId
  - handleMessage(sessionId, message) -> response
  - getUserEnrollments(userId)
- LMS Adapter
  - getCourseDeadlines(courseId, startDate, endDate)
  - syncAnnouncements(announcementPayload)
- AI Engine
  - generateResponse(prompt, context[], maxTokens)
  - embedText(text)

Naming & syntax: Method names above should be used in code stubs and tests for consistency with the rubric.

Sequence 2: Faculty posts announcement (mermaid)
MERMAID DIAGRAM START
sequenceDiagram
  participant F as Faculty UI
  participant API as API Gateway
  participant Auth as Auth
  participant Core as Core Assistant
  participant LMS as LMS Adapter
  participant Mail as Mail Adapter

  F->>API: POST /api/v1/courses/{id}/announcements {title, body}
  API->>Auth: check faculty privileges
  API->>Core: createAnnouncement(courseId, payload)
  Core->>LMS: createAnnouncementInLMS(courseId, payload)
  LMS-->>Core: confirmation
  Core->>Mail: sendCourseNotification(courseId, payload)
  Core-->>API: 201 Created
  API->>F: 201 Created
MERMAID DIAGRAM END

Methods table:
- createAnnouncement(courseId, payload)
- createAnnouncementInLMS(courseId, payload)
- sendCourseNotification(courseId, payload)

Sequence 3: Admin requests analytics (mermaid)
MERMAID DIAGRAM START
sequenceDiagram
  participant A as Admin UI
  participant API as API Gateway
  participant Auth as Auth
  participant Core as Core Assistant
  participant Analytics as Analytics Service
  participant DB as Postgres

  A->>API: GET /api/v1/analytics/enrollment?from=...&to=...
  API->>Auth: check admin role
  API->>Core: getEnrollmentStats(from,to)
  Core->>Analytics: queryEnrollmentAggregates(from,to)
  Analytics->>DB: read aggregated tables
  Analytics-->>Core: return stats
  Core-->>API: return result
  API->>A: render chart
MERMAID DIAGRAM END

Methods table:
- getEnrollmentStats(from,to)
- queryEnrollmentAggregates(from,to)

Acceptance for "Exceeds":
- Multiple sequence diagrams for chosen use cases exist.
- Methods table describes the methods for each lifeline and use-case-related endpoints.
- Method names reflect proper function call / REST syntax.

--------------------------------------------------------------------------------
Deployment Architecture

Deployment diagram (mermaid)
MERMAID DIAGRAM START
graph LR
  subgraph Cloud
    LB[Load Balancer]
    APIS[API Service (k8s)]
    CORE[Core Service (k8s)]
    AI[AI Engine (managed or private)]
    VDB[Vector DB (managed)]
    PG[Postgres (managed)]
    REDIS[Redis (managed)]
    MQ[Message Queue (optional, e.g., RabbitMQ)]
    STORAGE[Object Storage (S3)]
  end

  LB --> APIS
  APIS --> CORE
  CORE --> AI
  CORE --> VDB
  CORE --> PG
  CORE --> REDIS
  CORE --> MQ
  CORE --> STORAGE
MERMAID DIAGRAM END

Deployment table
- Load Balancer
  - Env: Cloud LB (AWS ALB / GCP LB)
  - Purpose: expose API, TLS termination
- API Service
  - Env: Kubernetes / App Service
  - Purpose: host API Gateway, rate-limiting
- Core Service
  - Env: Kubernetes (stateless pods)
  - Purpose: orchestrate conversation and call adapters
- AI Engine
  - Env: Managed (OpenAI) or controlled LLM (on-prem GPU)
  - Notes: For Iteration 1 we can use OpenAI + local retrieval; document cost/latency tradeoff
- Vector DB
  - Env: managed vector DB (Pinecone/Milvus)
  - Purpose: fast similarity search for content
- Postgres
  - Env: managed cloud RDBMS
  - Purpose: persistent user/permission/session data
- Redis
  - Env: managed cache
  - Purpose: session cache, short context storage, rate limiting
- Message Queue (optional)
  - Purpose: send email notifications asynchronously, decouple write path

Acceptance for "Exceeds":
- Domain-specific deployment diagram exists.
- Table lists elements and their deployment environment and purpose.
- Note: include a short security note for production (VPC, subnets, DB private, TLS).

Minimal deployment checklist to show iteration progress:
- Deploy API and Core to a single VM or dev k8s cluster
- Use managed Postgres and Redis or local docker-compose for demo
- Configure env variables for AI keys and LMS test credentials (do not commit secrets)

--------------------------------------------------------------------------------
Quality Attributes

Goal: Address a small number of quality attributes well for iteration 1. Strive for clarity and implementable checks.

Selected attributes for Iteration 1 (domain justification included):

1) Security / Privacy (critical in educational data)
- Requirement: Only enrolled users can access deadline and grade-related info.
- Implementation:
  - Use SSO (institution OIDC/SAML) + role claims in JWT
  - Backend authorization checks in Core/Adapters
  - Data minimization: redact PII from LLM prompts
- Tests / Evidence:
  - Unit tests that assert access denied for non-enrolled user
  - Example: tests/auth/test_lms_access.py

2) Availability / Fault tolerance
- Requirement: Basic HA for API during demo.
- Implementation:
  - Retry for transient LMS or AI API failures (exponential backoff)
  - Circuit breaker for external AI provider calls
- Tests / Evidence:
  - Integration test simulating AI timeout and checking graceful degraded response

3) Latency (response time)
- Requirement: User-facing responses within X seconds with cached context
- Implementation:
  - Cache user context & course deadlines in Redis for N minutes
  - Pre-compute embeddings for frequently asked docs
- Tests / Evidence:
  - Simple latency measurement script (scripts/measure_latency.sh)

4) Maintainability / Modularity
- Implementation:
  - Adapter pattern for external integrations (LMS, Calendar, Mail)
  - Clear API boundaries and README in src/adapters

Acceptance for "Exceeds":
- Each quality attribute is addressed and there is evidence (tests / scripts / instrumentation) that shows implementation or mitigation.
- Provide a minimal automated test or script for each attribute above.

Suggested quick test skeletons (to add under tests/):
- tests/test_authorization.py: asserts unauthorized user cannot fetch deadlines
- tests/test_retry_behavior.py: verifies fallback when AI times out

--------------------------------------------------------------------------------
Design Decisions

This table lists decisions made during iteration 1, alternatives, trade-offs, and justification.

Decision table:
- DD-1: Use a hybrid LLM + retrieval architecture (LLM with vector DB)
  - Alternatives: LLM-only; pure rules engine
  - Trade-offs / Rationale: Hybrid gives grounded answers, reduces hallucinations. LLM-only simpler but less accurate for institutional facts.
  - Status: Chosen

- DD-2: Use adapters for each external system (LMS, Calendar, Mail)
  - Alternatives: Direct code in Core
  - Trade-offs: Adapters decouple integrations, easier to test and replace. Slight overhead to implement adapters.
  - Status: Chosen

- DD-3: Store sessions in Redis for short-lived context
  - Alternatives: Store in Postgres
  - Trade-offs: Redis gives faster read/write for conversational state, TTL support. Postgres for long-term archival only.
  - Status: Chosen

- DD-4: Use managed vector DB (Pinecone) for Iteration 1
  - Alternatives: Self-hosted Milvus
  - Trade-offs: Managed reduces ops overhead for demo; higher cost.
  - Status: Chosen (re-evaluate later)

- DD-5: OpenAI managed model as first AI Engine
  - Alternatives: Self-hosted LLM on GPU
  - Trade-offs: Faster to implement + reliable for demo. Self-hosting gives control/cost savings at scale.
  - Status: Chosen (iteration 1)

Acceptance for "Exceeds":
- Table exists for iteration 1 & 2 (for now iteration 1 table above).
- Each decision has justification and at least one alternative with trade-offs.

--------------------------------------------------------------------------------
Analysis & Progress

Summary of analysis:
- Using hybrid retrieval + LLM reduces hallucinations for institutional facts and makes it straightforward to answer deadline and announcement queries with citations.
- Adapter pattern isolates integration complexity (LMS / Calendar) so we can implement mock adapters for iteration 1 and replace them later.

Progress table (example)
- Logical Architecture: Diagrams + component table — Complete — this file (ARCHITECTURE section)
- Sequences: 3 use case diagrams + methods — Complete — this file (SEQUENCES section)
- Deployment: Dev deployment diagram + table — Complete — this file (DEPLOYMENT section)
- Quality Attributes: Security, Availability, Latency documented — In progress — see QUALITY_ATTRIBUTES section; tests to add
- Design Decisions: DD table created — Complete — see DESIGN_DECISIONS section
- Implementation: API skeleton + mock adapters — Partially done — example skeleton included below — integrate in repo

Recommended next concrete tasks:
1. Create simple API skeleton in repo that exposes the listed endpoints (one-file demo is fine).
2. Add 2 tests under tests/ to prove authorization and retry behaviour and wire them into CI.
3. Export diagrams to PNG and add to folder for easy grading.
4. Add short demo screencast or screenshots of endpoints returning data.
